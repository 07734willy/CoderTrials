from __future__ import print_function
from subprocess import PIPE, run, Popen, TimeoutExpired
from argparse import ArgumentParser
import sys
import os
from time import sleep
from threading import Thread
try:
    from queue import Queue, Empty
except ImportError:
    from Queue import Queue, Empty
ON_POSIX = 'posix' in sys.builtin_module_names

def dequeue_input(queue):
    for line in iter(sys.stdin.readline, b''):
        queue.put(line)
        if _thread_break:
            break

def run_solver(command, is_piped, stdin_queue):
    #pipe_r, pipe_w = os.pipe()
    test_cases = []
    add_tests = "y"
    while add_tests == "y":
        if not is_piped:
            print(":input:")
        
        test_input = ""
        with Popen(command, stdout=PIPE, stdin=PIPE) as process:
            while process.poll() == None:
                try:
                    text = stdin_queue.get_nowait()
                except Empty:
                    sleep(0.1)
                    continue
                test_input += text
                process.stdin.write((text).encode("ascii"))
                process.stdin.flush()
            
            run_output = process.stdout.read().decode(sys.stdout.encoding)
            if not process.poll():
                test_cases.append((test_input, run_output))
                if not is_piped:
                    print(":output:\n{}".format(run_output))
        
        # We can't prompt whether to keep going, because it'll get logged into
        # the test cases as well
        if is_piped:
            break

        add_tests = "Q"
        #while add_tests not in "yn":
        #    print("Keep adding test cases? [y/n]")
        #    add_tests = stdin_queue.get_nowait().lower()
    return test_cases

def format_tests(test_cases):
    tests = []
    for test_input, test_output in test_cases:
        text = "input_lines: {}\n".format(len(test_input.split("\n")))
        text += test_input
        text += "\noutput_lines: {}\n".format(len(test_output.split("\n")))
        text += test_output
        tests.append(text)
    return "\n".join(tests) + "\n"

# Parse the command line options, return the result
def parse_options():
    parser = ArgumentParser()
    parser.add_argument('-a', action="store_true", dest="append", help="Write to the test case file in append mode")
    parser.add_argument('-v', action="store_true", dest="version", help="Print the version number")
    parser.add_argument('-f', metavar="FILENAME", dest="filename", type=str, default=None, help="Name of the test cases file")
    parser.add_argument('command', help="Shell command to run the solver program") 
    parser.add_argument('args', nargs="*", help="Arguments supplied to solver program")
    return parser.parse_args()

if __name__ == "__main__":
    args = parse_options()
    
    if args.version:
        print("Version: {0}".format(".".join(map(str, version))))
        sys.exit(0)

    new_file = not args.append or not os.path.isfile(args.filename)
    _thread_break = False

    with open(args.filename, "a" if args.append else "w+") if args.filename else sys.stdout as tests_file:
        if new_file:
            tests_file.write("# These test cases were auto-generated by /r/CoderTrials generator script\n")
            tests_file.write("# See https://old.reddit.com/r/CoderTrials/wiki/generator\n\n")

        stdin_queue = Queue()
        poller = Thread(target=dequeue_input, args=(stdin_queue,))
        poller.daemon = True
        poller.start()
        
        test_cases = run_solver([args.command] + args.args, args.filename is None, stdin_queue)
        tests_file.write(format_tests(test_cases))
        
